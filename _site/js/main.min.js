function getRandomBoolean() {
    return Math.random() >= .5;
}

function setAffixWidth() {
    $("#nav-submodules ul").width($("#nav-submodules").width());
}

var App = {
    baseUrl: null,
    alert: function(element, message, type, prepend) {
        var $alert = $('<div class="alert alert-' + type + '">' + '<button type="button" class="close" data-dismiss="alert">&times;</button>' + message + "</div>");
        if (prepend === false) $(element).append($alert); else $(element).prepend($alert);
        $alert.delay(2e3).fadeOut(1e3);
    },
    success: function(element, message, prepend) {
        if (!prepend) prepend = false;
        this.alert(element, message, "success", prepend);
    },
    info: function(element, message, prepend) {
        if (!prepend) prepend = false;
        this.alert(element, message, "info", prepend);
    },
    error: function(element, message, prepend) {
        if (!prepend) prepend = false;
        this.alert(element, message, "error", prepend);
    },
    sleep: function(milliseconds) {
        var startTime = new Date().getTime();
        while (new Date().getTime() < startTime + milliseconds) {}
        return true;
    }
};

function StackView(element) {
    this.element = element;
    this.context = element.getContext("2d");
    element.width = $(element).parent().width();
    this.width = element.width;
    this.height = element.height;
    this.colorBackground = "rgb(255, 255, 255)";
    this.colorItemDefault = "rgb(150, 255, 150)";
    this.colorItemTextDefault = "black";
    this.itemWidth = 100;
    this.fontSize = 14;
    this.stack = [];
    this.currentLevel = 0;
    this.itemsInRow = Math.round(this.width / (this.itemWidth + 10));
    this.directionToChar = function(direction) {
        switch (direction) {
          case "up":
            return "O";

          case "right":
            return "R";

          case "down":
            return "U";

          case "left":
            return "L";
        }
    };
    this.draw = function() {
        var index = 0;
        var indexStart;
        var j;
        indexStart = this.stack.length <= this.itemsInRow ? 0 : this.stack.length - this.itemsInRow;
        this.context.fillStyle = this.colorBackground;
        this.context.fillRect(0, 0, this.width, this.height);
        for (var i = indexStart; i < this.stack.length; i++) {
            var item = this.stack[i];
            var x = index * (this.itemWidth + 10);
            var y = 0;
            var efText = "EF: ";
            var mText = "M: ";
            this.context.fillStyle = item.colorBackground || this.colorItemDefault;
            this.context.fillRect(x, y, this.itemWidth, this.height);
            this.context.font = this.fontSize + "px Arial";
            this.context.fillStyle = item.colorText || this.colorItemTextDefault;
            x += 4;
            y += 4 + this.fontSize;
            for (j = 0; j < i; j++) {
                efText += this.directionToChar(this.stack[j].x) + " ";
            }
            this.context.fillText(efText, x, y);
            y += 4 + this.fontSize;
            for (j = 0; j < item.m.length; j++) {
                mText += this.directionToChar(item.m[j]) + " ";
            }
            this.context.fillText(mText, x, y);
            y += 4 + this.fontSize;
            this.context.fillText("X: " + this.directionToChar(item.x), x, y);
            index++;
        }
    };
    this.push = function(item) {
        this.currentLevel++;
        item.level = this.currentLevel;
        this.stack.push(item);
        this.draw();
    };
    this.pop = function() {
        this.currentLevel--;
        var item = this.stack.pop();
        this.draw();
        return item;
    };
    this.removeDirection = function(direction) {
        var item = this.stack.pop();
        item.m = _.reject(item.m, function(itemDirection) {
            return itemDirection == direction;
        });
        this.stack.push(item);
        this.draw();
    };
    this.reset = function() {
        this.stack = [];
        this.draw();
    };
}

$(function() {
    $(".help").popover({
        placement: "top",
        trigger: "hover"
    });
    if ($("#nav-submodules").length > 0) {
        var sections = $(".module h3");
        for (var i = 0; i < sections.length; i++) {
            var section = sections[i];
            $("#nav-submodules ul").append('<li><a href="#' + $(section).attr("id") + '">' + $(section).html() + "</li>");
        }
        if ($(window).width() > 768) {
            $("#nav-submodules ul").affix({
                offset: $("#nav-submodules ul").position()
            });
            $("#nav-submodules").scrollspy("refresh");
            $(window).resize(function() {
                if ($(window).width() > 768) {
                    setAffixWidth();
                } else {
                    setAffixWidth();
                }
            });
        }
        setAffixWidth();
    }
    $(".answer-item").draggable({
        cursor: "pointer"
    });
    $(".question-item").droppable({
        accept: ".answer-item",
        drop: function(event, ui) {
            $(ui.draggable).detach().css({
                top: 0,
                left: 0
            }).appendTo(this);
            var questionCount = $("#question-drop-labyrinth > li").length;
            var correntAnswerCount = 0;
            for (var i = 0; i < questionCount; i++) {
                var question = $("#question-drop-labyrinth > li").get(i);
                var answer = $(question).find(".answer-item");
                if (answer.length !== 1) {
                    return;
                }
                if ($(question).attr("data-question") == $(answer).attr("data-answer")) {
                    correntAnswerCount++;
                }
            }
            if (correntAnswerCount === questionCount) {
                App.success($("#answer-drag-labyrinth").parent().parent(), "Alle Fragen richtig beantwortet.", true);
            } else {
                App.error($("#answer-drag-labyrinth").parent().parent(), "Du hast mindestens eine Frage falsch beantwortet!", true);
            }
        }
    });
    $('[data-task="question"]').each(function(index) {
        console.log("Initialisiere Aufgabe: Frage", index);
        var _this = this;
        var questionCheck = $(this).find("#" + $(this).attr("data-check"));
        var questionResult = $(this).attr("data-result");
        var questionValue = $(this).find("#" + $(this).attr("data-value"));
        var questionFeedback = $(this).find(".control-result");
        questionCheck.on("click", function() {
            console.log("Prüfe Aufgabe: Frage Gruppe", index);
            questionFeedback.removeClass("has-error");
            questionFeedback.removeClass("has-success");
            if (questionValue.val() != questionResult) {
                questionFeedback.addClass("has-error");
                questionFeedback.find("label").html("Das Ergebnis war leider nicht richtig!");
            } else {
                questionFeedback.addClass("has-success");
                questionFeedback.find("label").html("Das Ergebnis ist richtig, Glückwunsch");
            }
        });
    });
    $('[data-task="question-group"]').each(function(index) {
        console.log("Initialisiere Aufgabe: Frage Gruppe", index);
        var _this = this;
        var questionCheck = $(this).find("#" + $(this).attr("data-check"));
        questionCheck.on("click", function() {
            console.log("Prüfe Aufgabe: Frage Gruppe", index);
            $(_this).find(".answer-correct").remove();
            $(_this).find(".answer-failed").remove();
            $(_this).find(".question-input").each(function(questionIndex) {
                if ($(this).val() == $(this).attr("data-answer")) {
                    $(this).after('<span class="answer-correct glyphicon glyphicon-ok">');
                } else {
                    $(this).after('<span class="answer-failed glyphicon glyphicon-remove">');
                }
            });
        });
    });
});

function MazeCell(top, right, bottom, left, x, y) {
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
    this.x = x;
    this.y = y;
    this.frontier = false;
    this.visited = false;
    this.chalked = false;
    this.string = false;
}

var Maze = Backbone.Model.extend({
    defaults: {
        element: null,
        context: null,
        squareSize: null,
        status: "reset",
        type: "manual",
        colorBackground: "rgb(255, 255, 255)",
        colorTorchBackground: "rgb(50, 50, 50)",
        colorWall: "rgb(255, 255, 255)",
        colorExit: "rgb(175, 255, 175)",
        colorPlayer: "rgb(255, 50, 50)",
        colorChalk: "rgb(170, 170, 210)",
        colorString: "rgb(0, 0, 0)",
        wallWidth: .5,
        rowCount: 20,
        torch: false,
        string: false,
        chalk: false,
        stack: false,
        speed: 150,
        squares: [],
        player: [ 0, 0 ],
        end: [ 0, 0 ],
        stackFrom: "",
        selectorStart: false,
        selectorStep: false,
        selectorStop: false,
        selectorReset: false,
        keyUp: 38,
        keyRight: 39,
        keyDown: 40,
        keyLeft: 37
    },
    createEnd: function() {
        var side = _.random(0, 3);
        var squares = this.get("squares");
        var rowCount = this.get("rowCount");
        var end = this.get("end");
        var x = 0;
        var y = 0;
        switch (side) {
          case 0:
            x = _.random(1, rowCount - 2);
            y = 0;
            squares[x][y].top = false;
            this.setFrontiers(x, y);
            break;

          case 1:
            x = rowCount - 1;
            y = _.random(1, rowCount - 2);
            squares[x][y].right = false;
            this.setFrontiers(x, y);
            break;

          case 2:
            x = _.random(1, rowCount - 2);
            y = rowCount - 1;
            squares[x][y].bottom = false;
            this.setFrontiers(x, y);
            break;

          case 3:
            x = 0;
            y = _.random(1, rowCount - 2);
            squares[x][y].left = false;
            this.setFrontiers(x, y);
            break;
        }
        end[0] = x;
        end[1] = y;
    },
    dig: function(x, y) {
        var sides = _.shuffle([ 0, 1, 2, 3 ]);
        var squares = this.get("squares");
        var rowCount = this.get("rowCount");
        for (var i = 0; i < 4; i++) {
            switch (sides[i]) {
              case 0:
                if (y - 1 >= 0 && squares[x][y - 1].visited === false) {
                    squares[x][y - 1].bottom = false;
                    squares[x][y].top = false;
                    return squares[x][y - 1];
                }
                break;

              case 1:
                if (x + 1 < rowCount && squares[x + 1][y].visited === false) {
                    squares[x + 1][y].left = false;
                    squares[x][y].right = false;
                    return squares[x + 1][y];
                }
                break;

              case 2:
                if (y + 1 < rowCount && squares[x][y + 1].visited === false) {
                    squares[x][y + 1].top = false;
                    squares[x][y].bottom = false;
                    return squares[x][y + 1];
                }
                break;

              case 3:
                if (x - 1 >= 0 && squares[x - 1][y].visited === false) {
                    squares[x - 1][y].right = false;
                    squares[x][y].left = false;
                    return squares[x - 1][y];
                }
                break;
            }
        }
        return null;
    },
    setFrontiers: function(x, y) {
        var squares = this.get("squares");
        if (squares[x + 1] && squares[x + 1][y].visited === false) squares[x + 1][y].frontier = true;
        if (squares[x - 1] && squares[x - 1][y].visited === false) squares[x - 1][y].frontier = true;
        if (squares[x][y + 1] && squares[x][y + 1].visited === false) squares[x][y + 1].frontier = true;
        if (squares[x][y - 1] && squares[x][y - 1].visited === false) squares[x][y - 1].frontier = true;
    },
    getFrontiers: function() {
        var frontiers = [];
        var squares = this.get("squares");
        var rowCount = this.get("rowCount");
        for (var x = 0; x < rowCount; x++) {
            for (var y = 0; y < rowCount; y++) {
                if (squares[x][y].frontier === true) {
                    frontiers.push(squares[x][y]);
                }
            }
        }
        return frontiers;
    },
    fillMaze: function(frontiers) {
        if (frontiers.length > 0) {
            var neighbor = frontiers.shift();
            var squares = this.get("squares");
            this.dig(neighbor.x, neighbor.y);
            this.setFrontiers(neighbor.x, neighbor.y);
            squares[neighbor.x][neighbor.y].visited = true;
            squares[neighbor.x][neighbor.y].frontier = false;
            this.fillMaze(this.getFrontiers());
        }
    },
    createMaze: function() {
        this.createEnd();
        this.fillMaze(this.getFrontiers());
    },
    setPlayer: function() {
        var pos = Math.round(this.get("rowCount") / 2);
        this.set({
            player: [ pos, pos ]
        });
    },
    drawWall: function(xFrom, yFrom, xTo, yTo) {
        var context = this.get("context");
        var squareSize = this.get("squareSize");
        context.beginPath();
        context.moveTo(xFrom * squareSize, yFrom * squareSize);
        context.lineTo(xTo * squareSize, yTo * squareSize);
        context.closePath();
        context.stroke();
    },
    drawField: function(x, y, exit) {
        var context = this.get("context");
        var chalk = this.get("chalk");
        var squares = this.get("squares");
        var squareSize = this.get("squareSize");
        var colorChalk = this.get("colorChalk");
        var colorBackground = this.get("colorBackground");
        var colorString = this.get("colorString");
        var colorExit = this.get("colorExit");
        if (exit === false) {
            if (chalk === true && squares[x][y].chalked === true) {
                context.fillStyle = colorChalk;
            } else {
                context.fillStyle = colorBackground;
            }
        } else {
            context.fillStyle = colorExit;
        }
        context.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
        if (squares[x][y].string === true) {
            context.beginPath();
            context.arc(x * squareSize + squareSize / 2, y * squareSize + squareSize / 2, squareSize / 3, 0, 2 * Math.PI);
            context.fillStyle = colorString;
            context.fill();
            context.closePath();
        }
    },
    drawPlayer: function(x, y, color) {
        var context = this.get("context");
        var squareSize = this.get("squareSize");
        context.beginPath();
        context.arc(x * squareSize + squareSize / 2, y * squareSize + squareSize / 2, squareSize / 3, 0, 2 * Math.PI);
        context.fillStyle = color;
        context.fill();
        context.closePath();
    },
    draw: function() {
        var context = this.get("context");
        var torch = this.get("torch");
        var status = this.get("status");
        var element = this.get("element");
        var squares = this.get("squares");
        var rowCount = this.get("rowCount");
        var end = this.get("end");
        var wallWidth = this.get("wallWidth");
        var player = this.get("player");
        var squareSize = this.get("squareSize");
        var colorTorchBackground = this.get("colorTorchBackground");
        var colorPlayer = this.get("colorPlayer");
        var colorBackground = this.get("colorBackground");
        var colorWall = this.get("colorWall");
        if (torch === true && status !== "finish") {
            context.fillStyle = colorTorchBackground;
            context.fillRect(0, 0, element.width, element.height);
            context.save();
            context.beginPath();
            context.arc(player[0] * squareSize, player[1] * squareSize, squareSize * rowCount / 7, 0, 2 * Math.PI);
            context.clip();
        }
        context.beginPath();
        context.fillStyle = colorBackground;
        context.fillRect(0, 0, element.width, element.height);
        context.fillStyle = colorWall;
        context.lineWidth = wallWidth;
        for (var x = 0; x < rowCount; x++) {
            for (var y = 0; y < rowCount; y++) {
                if (x === end[0] && y === end[1]) {
                    this.drawField(x, y, true);
                } else {
                    this.drawField(x, y, false);
                }
                if (squares[x][y].top === true) this.drawWall(x, y, x + 1, y);
                if (squares[x][y].right === true) this.drawWall(x + 1, y, x + 1, y + 1);
                if (squares[x][y].bottom === true) this.drawWall(x, y + 1, x + 1, y + 1);
                if (squares[x][y].left === true) this.drawWall(x, y, x, y + 1);
            }
        }
        this.drawPlayer(player[0], player[1], colorPlayer);
        if (torch === true && status !== "finish") {
            context.restore();
        }
    },
    firstWalk: function(x, y) {
        var squares = this.get("squares");
        if (squares[x][y - 1].bottom === false) return [ x, y - 1, "up" ];
        if (squares[x + 1][y].left === false) return [ x + 1, y, "right" ];
        if (squares[x][y + 1].top === false) return [ x, y + 1, "down" ];
        if (squares[x - 1][y].right === false) return [ x - 1, y, "left" ];
        return false;
    },
    canWalkTo: function(x, y, to) {
        var squares = this.get("squares");
        switch (to) {
          case "up":
            if (squares[x][y - 1] && squares[x][y - 1].bottom === false) {
                return [ x, y - 1, "up" ];
            }
            break;

          case "right":
            if (squares[x + 1] && squares[x + 1][y].left === false) {
                return [ x + 1, y, "right" ];
            }
            break;

          case "down":
            if (squares[x][y + 1] && squares[x][y + 1].top === false) {
                return [ x, y + 1, "down" ];
            }
            break;

          case "left":
            if (squares[x - 1] && squares[x - 1][y].right === false) {
                return [ x - 1, y, "left" ];
            }
            break;
        }
        return false;
    },
    chalked: function(x, y, to) {
        var squares = this.get("squares");
        switch (to) {
          case "up":
            if (squares[x][y - 1]) {
                return squares[x][y - 1].chalked;
            }
            break;

          case "right":
            if (squares[x + 1]) {
                return squares[x + 1][y].chalked;
            }
            break;

          case "down":
            if (squares[x][y + 1]) {
                return squares[x][y + 1].chalked;
            }
            break;

          case "left":
            if (squares[x - 1]) {
                return squares[x - 1][y].chalked;
            }
            break;
        }
        return false;
    },
    stringed: function(x, y, to) {
        var squares = this.get("squares");
        switch (to) {
          case "up":
            if (squares[x][y - 1]) {
                return squares[x][y - 1].string;
            }
            break;

          case "right":
            if (squares[x + 1]) {
                return squares[x + 1][y].string;
            }
            break;

          case "down":
            if (squares[x][y + 1]) {
                return squares[x][y + 1].string;
            }
            break;

          case "left":
            if (squares[x - 1]) {
                return squares[x - 1][y].string;
            }
            break;
        }
        return false;
    },
    oppositeDirection: function(to) {
        switch (to) {
          case "up":
            return "down";

          case "right":
            return "left";

          case "down":
            return "up";

          case "left":
            return "right";
        }
    },
    nextRandomWalk: function(x, y, to) {
        var possibilities = [];
        var directions = _.shuffle([ 0, 1, 2, 3 ]);
        var i = 0;
        for (i = 0; i < 4; i++) {
            switch (directions[i]) {
              case 0:
                if (this.canWalkTo(x, y, "up")) possibilities.push([ x, y - 1, "up" ]);
                break;

              case 1:
                if (this.canWalkTo(x, y, "right")) possibilities.push([ x + 1, y, "right" ]);
                break;

              case 2:
                if (this.canWalkTo(x, y, "down")) possibilities.push([ x, y + 1, "down" ]);
                break;

              case 3:
                if (this.canWalkTo(x, y, "left")) possibilities.push([ x - 1, y, "left" ]);
                break;
            }
        }
        for (i = 0; i < possibilities.length; i++) {
            if (possibilities[i][2] !== this.oppositeDirection(to)) return possibilities[i];
        }
        if (possibilities.length > 0) return possibilities[0]; else return false;
    },
    walkRandom: function(to) {
        if (this.get("status") === "start") {
            var _this = this;
            var next = false;
            var player = this.get("player");
            var end = this.get("end");
            var squares = this.get("squares");
            if (player[0] === end[0] && player[1] === end[1]) {
                this.finish();
                return;
            }
            if (!to) {
                next = this.firstWalk(player[0], player[1]);
            } else {
                next = this.nextRandomWalk(player[0], player[1], to);
            }
            if (next !== false) {
                this.set({
                    player: [ next[0], next[1] ]
                });
                if (this.get("chalk")) {
                    squares[next[0]][next[1]].chalked = true;
                }
                this.draw();
            } else {
                return;
            }
            setTimeout(function() {
                _this.walkRandom(next[2]);
            }, this.get("speed"));
        } else {
            return;
        }
    },
    walkBacktracking: function() {
        if (this.get("status") === "start" || this.get("status") === "step") {
            var _this = this;
            var next = false;
            var x = this.get("player")[0];
            var y = this.get("player")[1];
            var string = false;
            var end = this.get("end");
            var squares = this.get("squares");
            var m = [];
            if (x === end[0] && y === end[1]) {
                this.finish();
                return;
            }
            if (next === false && this.canWalkTo(x, y, "right") !== false && this.chalked(x, y, "right") === false) next = [ x + 1, y, "right" ];
            if (next === false && this.canWalkTo(x, y, "up") !== false && this.chalked(x, y, "up") === false) next = [ x, y - 1, "up" ];
            if (next === false && this.canWalkTo(x, y, "left") !== false && this.chalked(x, y, "left") === false) next = [ x - 1, y, "left" ];
            if (next === false && this.canWalkTo(x, y, "down") !== false && this.chalked(x, y, "down") === false) next = [ x, y + 1, "down" ];
            if (next !== false) {
                string = true;
            } else {
                if (next === false && this.canWalkTo(x, y, "right") !== false && this.stringed(x, y, "right") === true) next = [ x + 1, y, "right" ];
                if (next === false && this.canWalkTo(x, y, "up") !== false && this.stringed(x, y, "up") === true) next = [ x, y - 1, "up" ];
                if (next === false && this.canWalkTo(x, y, "left") !== false && this.stringed(x, y, "left") === true) next = [ x - 1, y, "left" ];
                if (next === false && this.canWalkTo(x, y, "down") !== false && this.stringed(x, y, "down") === true) next = [ x, y + 1, "down" ];
                if (next === false) {
                    if (next === false && this.canWalkTo(x, y, "right") !== false) next = [ x + 1, y, "right" ];
                    if (next === false && this.canWalkTo(x, y, "up") !== false) next = [ x, y - 1, "up" ];
                    if (next === false && this.canWalkTo(x, y, "left") !== false) next = [ x - 1, y, "left" ];
                    if (next === false && this.canWalkTo(x, y, "down") !== false) next = [ x, y + 1, "down" ];
                    if (next !== false) {
                        string = true;
                    }
                }
            }
            if (next === false) return;
            if (this.canWalkTo(next[0], next[1], "right") !== false) m.push("right");
            if (this.canWalkTo(next[0], next[1], "up") !== false) m.push("up");
            if (this.canWalkTo(next[0], next[1], "left") !== false) m.push("left");
            if (this.canWalkTo(next[0], next[1], "down") !== false) m.push("down");
            if (string === true) {
                squares[next[0]][next[1]].string = true;
                if (this.get("stack") !== false) {
                    this.get("stack").push({
                        m: m,
                        x: next[2]
                    });
                }
            } else {
                squares[x][y].string = false;
                if (this.get("stack") !== false) {
                    this.get("stack").pop();
                    this.get("stack").removeDirection(this.oppositeDirection(next[2]));
                }
            }
            if (this.get("chalk")) {
                squares[next[0]][next[1]].chalked = true;
            }
            this.set({
                player: [ next[0], next[1] ]
            });
            this.draw();
            if (this.get("status") === "start") {
                setTimeout(function() {
                    _this.walkBacktracking();
                }, this.get("speed"));
            }
        }
        return;
    },
    walk: function(direction) {
        var player = this.get("player");
        var end = this.get("end");
        var squares = this.get("squares");
        var canWalk = false;
        var x = player[0];
        var y = player[1];
        var xNext = false;
        var yNext = false;
        if (x === end[0] && y === end[1]) {
            this.finish();
            return;
        }
        switch (direction) {
          case "up":
            if (squares[x][y - 1] && squares[x][y].top === false) {
                xNext = x;
                yNext = y - 1;
                canWalk = true;
            }
            break;

          case "right":
            if (squares[x + 1] && squares[x + 1][y] && squares[x][y].right === false) {
                xNext = x + 1;
                yNext = y;
                canWalk = true;
            }
            break;

          case "down":
            if (squares[x][y + 1] && squares[x][y].bottom === false) {
                xNext = x;
                yNext = y + 1;
                canWalk = true;
            }
            break;

          case "left":
            if (squares[x - 1] && squares[x - 1][y] && squares[x][y].left === false) {
                xNext = x - 1;
                yNext = y;
                canWalk = true;
            }
            break;
        }
        if (canWalk) {
            this.trigger("walk", [ this, xNext, yNext ]);
            player[0] = xNext;
            player[1] = yNext;
            if (this.get("chalk")) {
                squares[xNext][yNext].chalked = true;
            }
            if (this.get("string")) {
                if (this.stringed(x, y, direction)) {
                    squares[x][y].string = false;
                }
                squares[xNext][yNext].string = true;
            }
            this.draw();
        }
        return canWalk;
    },
    walkUp: function() {
        this.walk("up");
    },
    walkRight: function() {
        this.walk("right");
    },
    walkDown: function() {
        this.walk("down");
    },
    walkLeft: function() {
        this.walk("left");
    },
    start: function() {
        var _this = this;
        if (this.get("status") === "reset") {
            if (this.get("stack") !== false) {
                this.get("stack").reset();
            }
        }
        if (this.get("status") !== "start") {
            switch (this.get("type")) {
              case "random":
                this.trigger("start", this);
                this.set({
                    status: "start"
                });
                this.walkRandom(null);
                break;

              case "manual":
                this.trigger("start", this);
                Mazes.stopAll();
                this.set({
                    status: "start"
                });
                $("body").keydown(function(e) {
                    switch (e.keyCode) {
                      case _this.get("keyUp"):
                        _this.walkUp();
                        break;

                      case _this.get("keyRight"):
                        _this.walkRight();
                        break;

                      case _this.get("keyDown"):
                        _this.walkDown();
                        break;

                      case _this.get("keyLeft"):
                        _this.walkLeft();
                        break;
                    }
                    if (e.keyCode === _this.get("keyUp") || e.keyCode === _this.get("keyRight") || e.keyCode === _this.get("keyDown") || e.keyCode === _this.get("keyLeft")) {
                        e.preventDefault();
                        return false;
                    }
                });
                break;

              case "backtracking":
                this.trigger("start", this);
                this.set({
                    status: "start"
                });
                this.walkBacktracking();
                break;
            }
            if (this.get("selectorStart")) $(this.get("selectorStart")).addClass("disabled");
            if (this.get("selectorStep")) $(this.get("selectorStep")).addClass("disabled");
            if (this.get("selectorStop")) $(this.get("selectorStop")).removeClass("disabled");
        }
    },
    step: function() {
        if (this.get("status") !== "start") {
            this.trigger("step", this);
            this.set({
                status: "step"
            });
            this.walkBacktracking();
        }
    },
    finish: function() {
        this.trigger("finish", this);
        this.set({
            status: "finish"
        });
        if (this.get("selectorStart") !== false) $(this.get("selectorStart")).addClass("disabled");
        if (this.get("selectorStep") !== false) $(this.get("selectorStep")).addClass("disabled");
        if (this.get("selectorStop") !== false) $(this.get("selectorStop")).addClass("disabled");
        this.draw();
        Mazes.unbindKeys();
    },
    stop: function() {
        if (this.get("status") !== "stop") {
            this.trigger("stop", this);
            this.set({
                status: "stop"
            });
            Mazes.unbindKeys();
            if (this.get("selectorStart") !== false) $(this.get("selectorStart")).removeClass("disabled");
            if (this.get("selectorStep") !== false) $(this.get("selectorStep")).removeClass("disabled");
            if (this.get("selectorStop") !== false) $(this.get("selectorStop")).addClass("disabled");
        }
    },
    reset: function() {
        console.log("reset", this.id);
        this.trigger("reset", this);
        this.init();
        this.set({
            status: "reset"
        });
        if (this.get("selectorStart") !== false) $(this.get("selectorStart")).removeClass("disabled");
        if (this.get("selectorStep") !== false) $(this.get("selectorStep")).removeClass("disabled");
        if (this.get("selectorStop") !== false) $(this.get("selectorStop")).addClass("disabled");
    },
    init: function() {
        var _this = this;
        var top = true;
        var right = true;
        var bottom = true;
        var left = true;
        var squares = this.get("squares");
        var element = this.get("element");
        var rowCount = this.get("rowCount");
        this.set({
            context: element.getContext("2d")
        });
        element.width = $(element).parent().width();
        element.height = $(element).width();
        squares = [];
        for (var x = 0; x < rowCount; x++) {
            squares[x] = [];
            for (var y = 0; y < rowCount; y++) {
                squares[x][y] = new MazeCell(true, true, true, true, x, y);
            }
        }
        this.set({
            squareSize: element.width / rowCount,
            squares: squares
        });
        this.setPlayer();
        this.createMaze();
        this.draw();
    },
    initialize: function() {
        var _this = this;
        this.init();
        if (this.get("selectorStart") !== false) {
            $(this.get("selectorStart")).on("click", function() {
                _this.start();
            });
        }
        if (this.get("selectorStep") !== false) {
            $(this.get("selectorStep")).on("click", function() {
                _this.step();
            });
        }
        if (this.get("selectorStop") !== false) {
            $(this.get("selectorStop")).on("click", function() {
                _this.stop();
            });
        }
        if (this.get("selectorReset") !== false) {
            $(this.get("selectorReset")).on("click", function() {
                _this.reset();
            });
        }
        this.draw();
    }
});

var MazeController = Backbone.Collection.extend({
    model: Maze,
    initialize: function() {
        console.log("Initialize Maze collection.");
        this.on("start", function(model) {
            console.log("Start maze:", model.id);
        });
        this.on("step", function(model) {
            console.log("Step maze:", model.id);
        });
        this.on("stop", function(model) {
            console.log("Stop maze:", model.id);
        });
        this.on("reset", function(model) {
            console.log("Reset maze:", model.id);
        });
        this.on("finish", function(model) {
            console.log("Finished maze:", model.id);
        });
    },
    stopAll: function() {
        this.forEach(function(model) {
            model.stop();
        });
    },
    unbindKeys: function() {
        $("body").unbind("keydown");
    }
});

var Mazes = new MazeController();

$(function() {
    Mazes.add([ {
        id: "random",
        element: $("#experiment-labyrinth-random").get(0),
        rowCount: 20,
        type: "random",
        selectorStart: "#experiment-labyrinth-random-start",
        selectorStop: "#experiment-labyrinth-random-stop",
        selectorReset: "#experiment-labyrinth-random-reset"
    }, {
        id: "manual",
        element: $("#experiment-labyrinth-manual").get(0),
        rowCount: 20,
        type: "manual",
        torch: true,
        selectorStart: "#experiment-labyrinth-manual-start",
        selectorStop: "#experiment-labyrinth-manual-stop",
        selectorReset: "#experiment-labyrinth-manual-reset"
    }, {
        id: "manual-small",
        element: $("#experiment-labyrinth-small").get(0),
        rowCount: 15,
        type: "manual",
        torch: true,
        selectorStart: "#experiment-labyrinth-small-start",
        selectorStop: "#experiment-labyrinth-small-stop",
        selectorReset: "#experiment-labyrinth-small-reset"
    }, {
        id: "chalk",
        element: $("#experiment-labyrinth-chalk").get(0),
        rowCount: 20,
        type: "manual",
        torch: true,
        chalk: true,
        selectorStart: "#experiment-labyrinth-chalk-start",
        selectorStop: "#experiment-labyrinth-chalk-stop",
        selectorReset: "#experiment-labyrinth-chalk-reset"
    }, {
        id: "string",
        element: $("#experiment-labyrinth-string").get(0),
        rowCount: 20,
        type: "backtracking",
        chalk: true,
        string: true,
        selectorStart: "#experiment-labyrinth-string-start",
        selectorStop: "#experiment-labyrinth-string-stop",
        selectorReset: "#experiment-labyrinth-string-reset"
    }, {
        id: "manual-string",
        element: $("#experiment-labyrinth-manual-string").get(0),
        rowCount: 20,
        type: "manual",
        torch: true,
        chalk: true,
        string: true,
        selectorStart: "#experiment-labyrinth-manual-string-start",
        selectorStop: "#experiment-labyrinth-manual-string-stop",
        selectorReset: "#experiment-labyrinth-manual-string-reset"
    }, {
        id: "stack",
        element: $("#experiment-labyrinth-stack").get(0),
        rowCount: 6,
        type: "backtracking",
        chalk: true,
        string: true,
        stack: new StackView($("#experiment-labyrinth-stack-display").get(0)),
        speed: 1e3,
        selectorStart: "#experiment-labyrinth-stack-start",
        selectorStep: "#experiment-labyrinth-stack-step",
        selectorStop: "#experiment-labyrinth-stack-stop",
        selectorReset: "#experiment-labyrinth-stack-reset",
        selectorStack: "#experiment-labyrinth-stack-display",
        selectorAlgorithm: "#experiment-labyrinth-stack-algorithm"
    } ]);
});

var DameCell = Backbone.Model.extend({
    defaults: {
        color: "black",
        queen: false,
        avaiable: true
    }
});

var Dame = Backbone.Model.extend({
    defaults: {
        element: null,
        context: null,
        squareSize: null,
        squares: [],
        queenCount: 0,
        colorWhiteBackground: "rgb(255, 255, 255)",
        colorWhiteText: "rgb(0, 0, 0)",
        colorWhiteNotAvailable: "rgb(230, 190, 190)",
        colorBlackBackground: "rgb(0, 0, 0)",
        colorBlackText: "rgb(255, 255, 255)",
        colorBlackNotAvailable: "rgb(70, 20, 20)",
        fontSize: 20,
        n: 8
    },
    markFields: function(x, y, avaiable) {
        var squares = this.get("squares");
        var n = this.get("n");
        for (var i = 0; i < n; i++) {
            squares[x][i].set({
                avaiable: avaiable
            });
            squares[i][y].set({
                avaiable: avaiable
            });
            if (i > 0) {
                if (x - i > 0 && y - i > 0) {
                    squares[x - i][y - i].set({
                        avaiable: avaiable
                    });
                }
                if (x + i < n && y - i > 0) {
                    squares[x + i][y - i].set({
                        avaiable: avaiable
                    });
                }
                if (x - i > 0 && y + i < n) {
                    squares[x - i][y + i].set({
                        avaiable: avaiable
                    });
                }
                if (x + i < n && y + i < n) {
                    squares[x + i][y + i].set({
                        avaiable: avaiable
                    });
                }
            }
        }
    },
    click: function(x, y) {
        var squares = this.get("squares");
        var n = this.get("n");
        if (squares[x][y].get("avaiable") === true) {
            squares[x][y].set({
                avaiable: false,
                queen: true
            });
            this.markFields(x, y, false);
            this.set({
                queenCount: this.get("queenCount") + 1
            });
        } else if (squares[x][y].get("queen") === true) {
            squares[x][y].set({
                avaiable: true,
                queen: false
            });
            this.markFields(x, y, true);
            this.set({
                queenCount: this.get("queenCount") - 1
            });
        }
        console.log(this.get("queenCount"));
        if (this.get("queenCount") >= n) {
            App.success($(this.get("element")).parent().find(".row"), "Alle Königinen erfolgreich platziert!");
        }
        this.set({
            squares: squares
        });
        this.draw();
    },
    getColor: function(colorName) {
        switch (colorName) {
          case "white":
            return this.get("colorWhiteBackground");

          case "black":
            return this.get("colorBlackBackground");
        }
    },
    getTextColor: function(colorName) {
        switch (colorName) {
          case "white":
            return this.get("colorWhiteText");

          case "black":
            return this.get("colorBlackText");
        }
    },
    getNotAvailableColor: function(colorName) {
        switch (colorName) {
          case "white":
            return this.get("colorWhiteNotAvailable");

          case "black":
            return this.get("colorBlackNotAvailable");
        }
    },
    drawField: function(x, y, square) {
        var context = this.get("context");
        var squareSize = this.get("squareSize");
        if (square.get("avaiable") === true) {
            context.fillStyle = this.getColor(square.get("color"));
        } else {
            context.fillStyle = this.getNotAvailableColor(square.get("color"));
        }
        context.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
        if (square.get("queen") === true) {
            context.font = this.get("fontSize") + "px Arial";
            context.fillStyle = this.getTextColor(square.get("color"));
            context.fillText("♛", x * squareSize + .12 * squareSize, y * squareSize + .75 * squareSize);
        }
    },
    draw: function() {
        var squares = this.get("squares");
        var n = this.get("n");
        for (var x = 0; x < n; x++) {
            for (var y = 0; y < n; y++) {
                this.drawField(x, y, squares[x][y]);
            }
        }
    },
    init: function() {
        var n = this.get("n");
        var squares = this.get("squares");
        var element = this.get("element");
        var color;
        squares = [];
        for (var x = 0; x < n; x++) {
            squares[x] = [];
            for (var y = 0; y < n; y++) {
                color = (x + y) % 2 === 0 ? "white" : "black";
                squares[x][y] = new DameCell({
                    color: color
                });
            }
        }
        element.width = $(element).parent().width();
        element.height = $(element).width();
        this.set({
            context: element.getContext("2d"),
            squareSize: element.width / n,
            fontSize: Math.floor(element.width / n * .75),
            squares: squares
        });
        this.draw();
    },
    initialize: function() {
        var _this = this;
        var element = this.get("element");
        this.init();
        $(element).on("click", function(e) {
            var x = Math.floor((e.pageX - $(this).offset().left) / _this.get("squareSize"));
            var y = Math.floor((e.pageY - $(this).offset().top) / _this.get("squareSize"));
            _this.click(x, y);
        });
    }
});

var DameController = Backbone.Collection.extend({
    model: Dame
});

var damen = new DameController();

$(function() {
    damen.add([ {
        id: "full",
        element: $("#experiment-dame-full").get(0),
        n: 8
    } ]);
    $("#experiment-dame-full-change").on("click", function(e) {
        var brett = damen.get("full");
        var n = parseInt($("#experiment-dame-full-n").val(), 10);
        if (_.isNumber(n) === false) {
            n = 8;
            $("#experiment-dame-full-n").val(n);
        }
        brett.set({
            n: n
        });
        brett.init();
        e.preventDefault();
        return false;
    });
});